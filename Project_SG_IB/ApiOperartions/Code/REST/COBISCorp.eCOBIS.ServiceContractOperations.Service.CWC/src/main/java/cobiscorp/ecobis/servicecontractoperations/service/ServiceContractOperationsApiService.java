
    /************************************************************/
    /*                     IMPORTANTE                           */
    /*   Esta aplicacion es parte de los  paquetes bancarios    */
    /*   propiedad de COBISCORP.                                */
    /*   Su uso no autorizado queda  expresamente  prohibido    */
    /*   asi como cualquier alteracion o agregado hecho  por    */
    /*   alguno de sus usuarios sin el debido consentimiento    */
    /*   por escrito de COBISCORP.                              */
    /*   Este programa esta protegido por la ley de derechos    */
    /*   de autor y por las y por las convenciones              */
    /*   internacionales de  propiedad intelectual. Su uso no   */
    /*   autorizado dara  derecho a  COBISCORP para obtener     */
    /*   ordenes de  secuestro o retencion y  para perseguir    */
    /*   penalmente a los autores de cualquier infraccion.      */
    /************************************************************/
    /*   This code was generated by CEN-SG.                     */
    /*   Changes to this file may cause incorrect behavior      */
    /*   and will be lost if the code is regenerated.           */
    /************************************************************/
    
    package  cobiscorp.ecobis.servicecontractoperations.service;
    
    import com.cobiscorp.cobis.cts.rest.client.api.exception.CTSRestException;
    import com.cobiscorp.cobis.commons.log.ILogger;
    import com.cobiscorp.cobis.commons.log.LogFactory;
    import com.cobiscorp.cobis.cts.rest.client.api.RowMapper;
    import com.cobiscorp.cobis.cts.rest.client.dto.MessageBlock;
    import com.cobiscorp.cobis.cts.rest.client.dto.ProcedureRequestAS;
    import com.cobiscorp.cobis.cts.rest.client.dto.ProcedureResponseAS;
    import com.cobiscorp.cobis.cts.rest.client.dto.ProcedureResponseParam;
    import com.cobiscorp.cobis.cts.rest.client.mapper.MapperResultUtil;
    import com.cobiscorp.cobis.cts.rest.client.mapper.ResultSetMapper;
    import com.cobiscorp.cobis.cts.rest.client.util.ErrorUtil;
    import com.cobiscorp.cobis.cwc.cts.rest.ICTSRestIntegrationService;
    import com.cobiscorp.cobis.jaxrs.publisher.SessionManager;
    import org.apache.felix.scr.annotations.*;
    import java.math.BigDecimal;
    import java.util.ArrayList;
    import java.util.List;
    import java.util.Arrays;
    
    import com.cobiscorp.cobis.cts.rest.client.util.ConverterUtil;
    import com.cobiscorp.cobis.cts.rest.client.util.ICTSTypes;
    
    import cobiscorp.ecobis.servicecontractoperations.service.IServiceContractOperationsApiService;
    import cobiscorp.ecobis.datacontractoperations.dto.*;
   
        @Component
    @Service({IServiceContractOperationsApiService.class})
    public class ServiceContractOperationsApiService implements IServiceContractOperationsApiService{

    @Reference(name = "ctsRestIntegrationService", referenceInterface = ICTSRestIntegrationService.class,
    bind = "setctsRestIntegrationService", unbind = "unsetctsRestIntegrationService", cardinality = ReferenceCardinality.MANDATORY_UNARY,
    policy = ReferencePolicy.DYNAMIC)
    private ICTSRestIntegrationService ctsRestIntegrationService;
    private static final ILogger LOGGER = LogFactory.getLogger(ServiceContractOperationsApiService.class);

    
          /**
          * Create new customers
          */
         @Override
			//Have DTO
			public CreateCustomerResponse createCustomer(CreateCustomerRequest inCreateCustomerRequest  )throws CTSRestException{
	  LOGGER.logDebug("Start service execution: createCustomer");
      CreateCustomerResponse outCreateCustomerResponse  = new CreateCustomerResponse();
          
      //create procedure
      ProcedureRequestAS procedureRequestAS = new ProcedureRequestAS("");
      
      //execute procedure
      ProcedureResponseAS response = ctsRestIntegrationService.execute(SessionManager.getSessionId(), null,procedureRequestAS);

      List<MessageBlock> errors = ErrorUtil.getErrors(response);
      //throw error
      if(errors!= null && errors.size()> 0){
      LOGGER.logDebug("Procedure execution returns error");
      if ( LOGGER.isDebugEnabled() ) {
      for (int i = 0; i < errors.size(); i++) {
      LOGGER.logDebug("CTSErrorMessage: " + errors.get(i));
      }
      }
      throw new CTSRestException("Procedure Response has errors", null, errors);
      }
      LOGGER.logDebug("Procedure ok");
      //Init map returns
      int mapTotal=0;
      int mapBlank=0;
      
      //End map returns
      if(mapBlank!=0&&mapBlank==mapTotal){
      LOGGER.logDebug("No data found");
      throw new CTSRestException("404",null);
      }
      
        LOGGER.logDebug("Ends service execution: createCustomer");
        //returns data
        return outCreateCustomerResponse;
      }
    
          /**
          * Encrypt Data
          */
         @Override
			// Return List
			public  List<ResponseEncriptData>  encryptData(RequestEncriptData inRequestEncriptData  )throws CTSRestException{
	  LOGGER.logDebug("Start service execution: encryptData");
      List<ResponseEncriptData> outSingleResponseEncriptData  = new ArrayList<>();
          
      //create procedure
      ProcedureRequestAS procedureRequestAS = new ProcedureRequestAS("cob_procesador..sp_encryptData");
      
        procedureRequestAS.addInputParam("@t_trn",ICTSTypes.SQLINT4,"18500088");
      procedureRequestAS.addInputParam("@i_external_customer_id",ICTSTypes.SQLINT4,String.valueOf(inRequestEncriptData.getExternalCustomerId()));
      procedureRequestAS.addInputParam("@i_password",ICTSTypes.SQLVARCHAR,inRequestEncriptData.getPassword());
      
      //execute procedure
      ProcedureResponseAS response = ctsRestIntegrationService.execute(SessionManager.getSessionId(), null,procedureRequestAS);

      List<MessageBlock> errors = ErrorUtil.getErrors(response);
      //throw error
      if(errors!= null && errors.size()> 0){
      LOGGER.logDebug("Procedure execution returns error");
      if ( LOGGER.isDebugEnabled() ) {
      for (int i = 0; i < errors.size(); i++) {
      LOGGER.logDebug("CTSErrorMessage: " + errors.get(i));
      }
      }
      throw new CTSRestException("Procedure Response has errors", null, errors);
      }
      LOGGER.logDebug("Procedure ok");
      //Init map returns
      int mapTotal=0;
      int mapBlank=0;
      
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(0).getData().getRows().size()>0) {
                    //----------------Assume Array return
                    List<ResponseEncriptData> returnResponseEncriptData = MapperResultUtil.mapToList(response.getResultSets().get(0), new RowMapper<ResponseEncriptData>() { 
                    @Override
                    public ResponseEncriptData mapRow(ResultSetMapper resultSetMapper, int index) {
                    ResponseEncriptData dto = new ResponseEncriptData();
                    
                          dto.setSuccess(resultSetMapper.getBooleanWrapper(1));
                          dto.setPassword(resultSetMapper.getString(2));
							dto.messageInstance().setMessage(resultSetMapper.getString(3));
							dto.messageInstance().setCode(resultSetMapper.getInteger(4));
                    return dto;
                    }
                    },false);
                    outSingleResponseEncriptData=returnResponseEncriptData ;
                    
            }else {
            mapBlank++;

            }
          
      //End map returns
      if(mapBlank!=0&&mapBlank==mapTotal){
      LOGGER.logDebug("No data found");
      throw new CTSRestException("404",null);
      }
      
        LOGGER.logDebug("Ends service execution: encryptData");
        //returns data
        return outSingleResponseEncriptData;
      }
    
          /**
          * Service to generate and send an OTP to the client
          */
         @Override
			// Return List
			public  List<ResponseOtp>  generateTransactionFactor(RequestOtp inRequestOtp  )throws CTSRestException{
	  LOGGER.logDebug("Start service execution: generateTransactionFactor");
      List<ResponseOtp> outSingleResponseOtp  = new ArrayList<>();
          
      //create procedure
      ProcedureRequestAS procedureRequestAS = new ProcedureRequestAS("cob_procesador..administra_token");
      
        procedureRequestAS.addInputParam("@t_trn",ICTSTypes.SQLINT4,"18500090");
      procedureRequestAS.addInputParam("@i_external_customer_id",ICTSTypes.SQLINT4,String.valueOf(inRequestOtp.getExternalCustomerId()));
      
      //execute procedure
      ProcedureResponseAS response = ctsRestIntegrationService.execute(SessionManager.getSessionId(), null,procedureRequestAS);

      List<MessageBlock> errors = ErrorUtil.getErrors(response);
      //throw error
      if(errors!= null && errors.size()> 0){
      LOGGER.logDebug("Procedure execution returns error");
      if ( LOGGER.isDebugEnabled() ) {
      for (int i = 0; i < errors.size(); i++) {
      LOGGER.logDebug("CTSErrorMessage: " + errors.get(i));
      }
      }
      throw new CTSRestException("Procedure Response has errors", null, errors);
      }
      LOGGER.logDebug("Procedure ok");
      //Init map returns
      int mapTotal=0;
      int mapBlank=0;
      
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(0).getData().getRows().size()>0) {
                    //----------------Assume Array return
                    List<ResponseOtp> returnResponseOtp = MapperResultUtil.mapToList(response.getResultSets().get(0), new RowMapper<ResponseOtp>() { 
                    @Override
                    public ResponseOtp mapRow(ResultSetMapper resultSetMapper, int index) {
                    ResponseOtp dto = new ResponseOtp();
                    
                          dto.setSuccess(resultSetMapper.getBooleanWrapper(1));
							dto.messageInstance().setCode(resultSetMapper.getInteger(2));
							dto.messageInstance().setMessage(resultSetMapper.getString(3));
                    return dto;
                    }
                    },false);
                    outSingleResponseOtp=returnResponseOtp ;
                    
            }else {
            mapBlank++;

            }
          
      //End map returns
      if(mapBlank!=0&&mapBlank==mapTotal){
      LOGGER.logDebug("No data found");
      throw new CTSRestException("404",null);
      }
      
        LOGGER.logDebug("Ends service execution: generateTransactionFactor");
        //returns data
        return outSingleResponseOtp;
      }
    
          /**
          * Get catalog
          */
         @Override
			//Have DTO
			public ResponseCatalog getCatalog(RequestCatalog inRequestCatalog  )throws CTSRestException{
	  LOGGER.logDebug("Start service execution: getCatalog");
      ResponseCatalog outResponseCatalog  = new ResponseCatalog();
          
      //create procedure
      ProcedureRequestAS procedureRequestAS = new ProcedureRequestAS("cob_procesador..sp_get_catalog_data");
      
        procedureRequestAS.addInputParam("@t_trn",ICTSTypes.SQLINT4,"18500087");
      procedureRequestAS.addInputParam("@i_catalog",ICTSTypes.SQLVARCHAR,inRequestCatalog.getCatalogueTable());
      
      //execute procedure
      ProcedureResponseAS response = ctsRestIntegrationService.execute(SessionManager.getSessionId(), null,procedureRequestAS);

      List<MessageBlock> errors = ErrorUtil.getErrors(response);
      //throw error
      if(errors!= null && errors.size()> 0){
      LOGGER.logDebug("Procedure execution returns error");
      if ( LOGGER.isDebugEnabled() ) {
      for (int i = 0; i < errors.size(); i++) {
      LOGGER.logDebug("CTSErrorMessage: " + errors.get(i));
      }
      }
      throw new CTSRestException("Procedure Response has errors", null, errors);
      }
      LOGGER.logDebug("Procedure ok");
      //Init map returns
      int mapTotal=0;
      int mapBlank=0;
      
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(0).getData().getRows().size()>0) {	
								//---------NO Array
								CatalogueItems [] returnCatalogueItems = MapperResultUtil.mapToArray(response.getResultSets().get(0), new RowMapper<CatalogueItems>() { 
                    @Override
                    public CatalogueItems mapRow(ResultSetMapper resultSetMapper, int index) {
                    CatalogueItems dto = new CatalogueItems();
                    
                          dto.setCode(resultSetMapper.getString(1));
                          dto.setName(resultSetMapper.getString(2));
                    return dto;
                    }
                    },false);

                    outResponseCatalog.setCatalogueItems(returnCatalogueItems);
                        // break;
                      
            }else {
            mapBlank++;

            }
          
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(1).getData().getRows().size()>0) {	
								//---------NO Array
								Message returnMessage = MapperResultUtil.mapOneRowToObject(response.getResultSets().get(1), new RowMapper<Message>() { 
                    @Override
                    public Message mapRow(ResultSetMapper resultSetMapper, int index) {
                    Message dto = new Message();
                    
                          dto.setCode(resultSetMapper.getInteger(1));
                          dto.setMessage(resultSetMapper.getString(2));
                    return dto;
                    }
                    },false);

                    outResponseCatalog.setMessage(returnMessage);
                        // break;
                      
            }else {
            mapBlank++;

            }
          
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(2).getData().getRows().size()>0) {	
								//---------NO Array
								ResponseCatalog returnResponseCatalog = MapperResultUtil.mapOneRowToObject(response.getResultSets().get(2), new RowMapper<ResponseCatalog>() { 
                    @Override
                    public ResponseCatalog mapRow(ResultSetMapper resultSetMapper, int index) {
                    ResponseCatalog dto = new ResponseCatalog();
                    
                          dto.setSuccess(resultSetMapper.getBooleanWrapper(1));
                    return dto;
                    }
                    },false);

                    outResponseCatalog.setSuccess(true);
                        // break;
                      
            }else {
            mapBlank++;

            }
          
      //End map returns
      if(mapBlank!=0&&mapBlank==mapTotal){
      LOGGER.logDebug("No data found");
      throw new CTSRestException("404",null);
      }
      
        LOGGER.logDebug("Ends service execution: getCatalog");
        //returns data
        return outResponseCatalog;
      }
    
          /**
          * View Customer Information
          */
         @Override
			//Have DTO
			public ResponseGetUserEntityInformation getUserEntityInformation(RequestGetUserEntityInformation inRequestGetUserEntityInformation  )throws CTSRestException{
	  LOGGER.logDebug("Start service execution: getUserEntityInformation");
      ResponseGetUserEntityInformation outResponseGetUserEntityInformation  = new ResponseGetUserEntityInformation();
          
      //create procedure
      ProcedureRequestAS procedureRequestAS = new ProcedureRequestAS("cob_procesador..sp_getCustomer");
      
        procedureRequestAS.addInputParam("@t_trn",ICTSTypes.SQLINT4,"18500092");
      procedureRequestAS.addInputParam("@i_externalCustomerId",ICTSTypes.SQLINT4,String.valueOf(inRequestGetUserEntityInformation.getExternalCustomerId()));
      
      //execute procedure
      ProcedureResponseAS response = ctsRestIntegrationService.execute(SessionManager.getSessionId(), null,procedureRequestAS);

      List<MessageBlock> errors = ErrorUtil.getErrors(response);
      //throw error
      if(errors!= null && errors.size()> 0){
      LOGGER.logDebug("Procedure execution returns error");
      if ( LOGGER.isDebugEnabled() ) {
      for (int i = 0; i < errors.size(); i++) {
      LOGGER.logDebug("CTSErrorMessage: " + errors.get(i));
      }
      }
      throw new CTSRestException("Procedure Response has errors", null, errors);
      }
      LOGGER.logDebug("Procedure ok");
      //Init map returns
      int mapTotal=0;
      int mapBlank=0;
      
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(0).getData().getRows().size()>0) {	
								//---------NO Array
								ResponseGetUserEntityInformation returnResponseGetUserEntityInformation = MapperResultUtil.mapOneRowToObject(response.getResultSets().get(0), new RowMapper<ResponseGetUserEntityInformation>() { 
                    @Override
                    public ResponseGetUserEntityInformation mapRow(ResultSetMapper resultSetMapper, int index) {
                    ResponseGetUserEntityInformation dto = new ResponseGetUserEntityInformation();
                    
                          dto.setSuccess(resultSetMapper.getBooleanWrapper(17));
                          dto.setRegistrationDate(resultSetMapper.getCalendar(1));
                          dto.setModifyDate(resultSetMapper.getCalendar(2));
                          dto.setCompleteName(resultSetMapper.getString(3));
                          dto.setEntityType(resultSetMapper.getString(4));
                          dto.setIdentityCard(resultSetMapper.getString(5));
                          dto.setBirthDate(resultSetMapper.getCalendar(9));
                          dto.setFirstName(resultSetMapper.getString(6));
                          dto.setSecondName(resultSetMapper.getString(7));
                          dto.setRFC(resultSetMapper.getString(12));
                          dto.setMail(resultSetMapper.getString(13));
                          dto.setPhoneNumber(resultSetMapper.getString(14));
                          dto.setCustomerLevel(resultSetMapper.getString(15));
                          dto.setAddressId(resultSetMapper.getInteger(16));
							dto.messageInstance().setCode(resultSetMapper.getInteger(18));
							dto.messageInstance().setMessage(resultSetMapper.getString(19));
                          dto.setGender(resultSetMapper.getString(8));
                    return dto;
                    }
                    },false);

               //    outResponseGetUserEntityInformation.set(returnResponseGetUserEntityInformation);
                        // break;
                    			outResponseGetUserEntityInformation=	returnResponseGetUserEntityInformation;
                      
            }else {
            mapBlank++;

            }
          
      //End map returns
      if(mapBlank!=0&&mapBlank==mapTotal){
      LOGGER.logDebug("No data found");
      throw new CTSRestException("404",null);
      }
      
        LOGGER.logDebug("Ends service execution: getUserEntityInformation");
        //returns data
        return outResponseGetUserEntityInformation;
      }
     @Override
			//Have DTO
			public ResponseValidateCustomerIdentityCard validateCustomerIdentityCard(RequestValidateCustomerIdentityCard inRequestValidateCustomerIdentityCard  )throws CTSRestException{
	  LOGGER.logDebug("Start service execution: validateCustomerIdentityCard");
      ResponseValidateCustomerIdentityCard outResponseValidateCustomerIdentityCard  = new ResponseValidateCustomerIdentityCard();
          
      //create procedure
      ProcedureRequestAS procedureRequestAS = new ProcedureRequestAS("cobis..sp_validate_identity_card_api");
      
        procedureRequestAS.addInputParam("@t_trn",ICTSTypes.SQLINT4,"18500093");
      procedureRequestAS.addInputParam("@curp",ICTSTypes.SQLVARCHAR,inRequestValidateCustomerIdentityCard.getIdentityCard());
      
      //execute procedure
      ProcedureResponseAS response = ctsRestIntegrationService.execute(SessionManager.getSessionId(), null,procedureRequestAS);

      List<MessageBlock> errors = ErrorUtil.getErrors(response);
      //throw error
      if(errors!= null && errors.size()> 0){
      LOGGER.logDebug("Procedure execution returns error");
      if ( LOGGER.isDebugEnabled() ) {
      for (int i = 0; i < errors.size(); i++) {
      LOGGER.logDebug("CTSErrorMessage: " + errors.get(i));
      }
      }
      throw new CTSRestException("Procedure Response has errors", null, errors);
      }
      LOGGER.logDebug("Procedure ok");
      //Init map returns
      int mapTotal=0;
      int mapBlank=0;
      
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(0).getData().getRows().size()>0) {
                    //----------------SingleResult
                    ResponseValidateCustomerIdentityCard returnResponseValidateCustomerIdentityCard = MapperResultUtil.mapOneRowToObject(response.getResultSets().get(0), new RowMapper<ResponseValidateCustomerIdentityCard>() { 
                        //----------------isOutDTO
                        @Override
                        public ResponseValidateCustomerIdentityCard mapRow(ResultSetMapper resultSetMapper, int index) {
                        ResponseValidateCustomerIdentityCard dto = new ResponseValidateCustomerIdentityCard();
                        
                              dto.setSuccess(resultSetMapper.getBooleanWrapper(1));
                        return dto;
                        }
                        },false);
                        outResponseValidateCustomerIdentityCard=returnResponseValidateCustomerIdentityCard;
            }else {
            mapBlank++;

            }
          
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(1).getData().getRows().size()>0) {	
								//---------NO Array
								ResponseValidateCustomerIdentityCard returnResponseValidateCustomerIdentityCard = MapperResultUtil.mapOneRowToObject(response.getResultSets().get(1), new RowMapper<ResponseValidateCustomerIdentityCard>() { 
                    @Override
                    public ResponseValidateCustomerIdentityCard mapRow(ResultSetMapper resultSetMapper, int index) {
                    ResponseValidateCustomerIdentityCard dto = new ResponseValidateCustomerIdentityCard();
                    
							dto.messageInstance().setCode(resultSetMapper.getInteger(1));
							dto.messageInstance().setMessage(resultSetMapper.getString(2));
                    return dto;
                    }
                    },false);

                    outResponseValidateCustomerIdentityCard.setMessage(returnResponseValidateCustomerIdentityCard.getMessage());
                        // break;
                      
            }else {
            mapBlank++;

            }
          
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(2).getData().getRows().size()>0) {	
								//---------NO Array
								ResponseValidateCustomerIdentityCard returnResponseValidateCustomerIdentityCard = MapperResultUtil.mapOneRowToObject(response.getResultSets().get(2), new RowMapper<ResponseValidateCustomerIdentityCard>() { 
                    @Override
                    public ResponseValidateCustomerIdentityCard mapRow(ResultSetMapper resultSetMapper, int index) {
                    ResponseValidateCustomerIdentityCard dto = new ResponseValidateCustomerIdentityCard();
                    
                          dto.setExternalCustomerId(resultSetMapper.getInteger(1));
                    return dto;
                    }
                    },false);

                    outResponseValidateCustomerIdentityCard.setExternalCustomerId(returnResponseValidateCustomerIdentityCard.getExternalCustomerId());
                        // break;
                      
            }else {
            mapBlank++;

            }
          
      //End map returns
      if(mapBlank!=0&&mapBlank==mapTotal){
      LOGGER.logDebug("No data found");
      throw new CTSRestException("404",null);
      }
      
        LOGGER.logDebug("Ends service execution: validateCustomerIdentityCard");
        //returns data
        return outResponseValidateCustomerIdentityCard;
      }
    
          /**
          * Validate Identity
          */
         @Override
			//Have DTO
			public ResponseValidateIdentity validateIdentity(RequestValidateIdentity inRequestValidateIdentity  )throws CTSRestException{
	  LOGGER.logDebug("Start service execution: validateIdentity");
      ResponseValidateIdentity outResponseValidateIdentity  = new ResponseValidateIdentity();
          
      //create procedure
      ProcedureRequestAS procedureRequestAS = new ProcedureRequestAS("cob_procesador..sp_validate_identity");
      
        procedureRequestAS.addInputParam("@t_trn",ICTSTypes.SQLINT4,"18500091");
      procedureRequestAS.addInputParam("@i_type",ICTSTypes.SQLVARCHAR,inRequestValidateIdentity.getType());
      procedureRequestAS.addInputParam("@i_imageAnverso",ICTSTypes.SQLVARCHAR,inRequestValidateIdentity.getImageAnverso());
      procedureRequestAS.addInputParam("@i_imageReverso",ICTSTypes.SQLVARCHAR,inRequestValidateIdentity.getImageReverso());
      procedureRequestAS.addInputParam("@i_imageDomicile",ICTSTypes.SQLVARCHAR,inRequestValidateIdentity.getImageDomicile());
      procedureRequestAS.addOutputParam("@salida",ICTSTypes.SQLVARCHAR,"0");
      
      //execute procedure
      ProcedureResponseAS response = ctsRestIntegrationService.execute(SessionManager.getSessionId(), null,procedureRequestAS);

      List<MessageBlock> errors = ErrorUtil.getErrors(response);
      //throw error
      if(errors!= null && errors.size()> 0){
      LOGGER.logDebug("Procedure execution returns error");
      if ( LOGGER.isDebugEnabled() ) {
      for (int i = 0; i < errors.size(); i++) {
      LOGGER.logDebug("CTSErrorMessage: " + errors.get(i));
      }
      }
      throw new CTSRestException("Procedure Response has errors", null, errors);
      }
      LOGGER.logDebug("Procedure ok");
      //Init map returns
      int mapTotal=0;
      int mapBlank=0;
      
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(0).getData().getRows().size()>0) {	
								//---------NO Array
								ResponseValidateIdentity returnResponseValidateIdentity = MapperResultUtil.mapOneRowToObject(response.getResultSets().get(0), new RowMapper<ResponseValidateIdentity>() { 
                    @Override
                    public ResponseValidateIdentity mapRow(ResultSetMapper resultSetMapper, int index) {
                    ResponseValidateIdentity dto = new ResponseValidateIdentity();
                    
                          dto.setSuccess(resultSetMapper.getBooleanWrapper(1));
                    return dto;
                    }
                    },false);

                    outResponseValidateIdentity.setSuccess(returnResponseValidateIdentity.isSuccess());
                        // break;
                      
            }else {
            mapBlank++;

            }
          
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(1).getData().getRows().size()>0) {	
								//---------NO Array
								Message returnMessage = MapperResultUtil.mapOneRowToObject(response.getResultSets().get(1), new RowMapper<Message>() { 
                    @Override
                    public Message mapRow(ResultSetMapper resultSetMapper, int index) {
                    Message dto = new Message();
                    
                          dto.setCode(resultSetMapper.getInteger(1));
                          dto.setMessage(resultSetMapper.getString(2));
                    return dto;
                    }
                    },false);

                    outResponseValidateIdentity.setMessage(returnMessage);
                        // break;
                      
            }else {
            mapBlank++;

            }
          
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(2).getData().getRows().size()>0) {	
								//---------NO Array
								ResponseValidateIdentity returnResponseValidateIdentity = MapperResultUtil.mapOneRowToObject(response.getResultSets().get(2), new RowMapper<ResponseValidateIdentity>() { 
                    @Override
                    public ResponseValidateIdentity mapRow(ResultSetMapper resultSetMapper, int index) {
                    ResponseValidateIdentity dto = new ResponseValidateIdentity();
                    
                          dto.setVerificationNumber(resultSetMapper.getString(1));
                    return dto;
                    }
                    },false);

                    outResponseValidateIdentity.setVerificationNumber(returnResponseValidateIdentity.getVerificationNumber());
                        // break;
                      
            }else {
            mapBlank++;

            }
          
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(3).getData().getRows().size()>0) {	
								//---------NO Array
								ResponseValidateIdentity returnResponseValidateIdentity = MapperResultUtil.mapOneRowToObject(response.getResultSets().get(3), new RowMapper<ResponseValidateIdentity>() { 
                    @Override
                    public ResponseValidateIdentity mapRow(ResultSetMapper resultSetMapper, int index) {
                    ResponseValidateIdentity dto = new ResponseValidateIdentity();
                    
                          dto.setEventName(resultSetMapper.getString(1));
                    return dto;
                    }
                    },false);

                    outResponseValidateIdentity.setEventName(returnResponseValidateIdentity.getEventName());
                        // break;
                      
            }else {
            mapBlank++;

            }
          
      //End map returns
      if(mapBlank!=0&&mapBlank==mapTotal){
      LOGGER.logDebug("No data found");
      throw new CTSRestException("404",null);
      }
     //  outResponseValidateIdentity.setSuccess(getOutValue(String.class, "@salida", response.getParams()));
            
        LOGGER.logDebug("Ends service execution: validateIdentity");
        //returns data
        return outResponseValidateIdentity;
      }
    

    protected void setctsRestIntegrationService(ICTSRestIntegrationService ctsRestIntegrationService){
      this.ctsRestIntegrationService = ctsRestIntegrationService;
    }

    protected void unsetctsRestIntegrationService(ICTSRestIntegrationService ctsRestIntegrationService){
      this.ctsRestIntegrationService = null;
    }

    @SuppressWarnings("unchecked")
    private <T extends Object> T getOutValue(Class<T> type, String name, List<ProcedureResponseParam> params) throws CTSRestException {
      for (ProcedureResponseParam param : params) {
        if(param.getName().equals(name)) {
          if(type.getCanonicalName() == "java.lang.String") {
            return (T) param.getValue();
          }
          return parse(type, param.getValue());
        }
      }
      LOGGER.logError("Output param " + name + " not found");
      throw new CTSRestException("404",null);
    }
    
    @SuppressWarnings("unchecked")
    private <T extends Object> T parse(Class<T> type, String value) {
      if (value != null && !"null".equals(value)) {
        if (value.trim().length() == 0) {
          if (type.getCanonicalName().equals("java.lang.Character")) {
            Character ch = ' ';
            return (T) ch;
          } else {
            return null;
          }
        } else {
          switch (type.getCanonicalName()) {
            case "java.lang.Byte":
              return (T) new Byte(value);
            case "java.lang.Long":
              return (T) new Long(value);
            case "java.lang.Double":
              return (T) new Double(value);
            case "java.lang.Integer":
              return (T) new Integer(value);
            case "java.util.Calendar":
              return (T) ConverterUtil.stringToCalendar(value);
            case "java.lang.Boolean":
              return (T) new Boolean(value);
            case "java.math.BigDecimal":
              return (T) new BigDecimal(value);
            case "java.lang.Character":
              Character ch = value.substring(0, value.length() - 1).charAt(0);
              return (T) ch;
            default:
              break;
          }
        }
      }
      return null;
    }
    
    }

  