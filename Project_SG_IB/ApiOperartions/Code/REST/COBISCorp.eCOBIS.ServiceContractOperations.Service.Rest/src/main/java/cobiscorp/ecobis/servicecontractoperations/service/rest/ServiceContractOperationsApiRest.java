
    /************************************************************/
    /*                     IMPORTANTE                           */
    /*   Esta aplicacion es parte de los  paquetes bancarios    */
    /*   propiedad de COBISCORP.                                */
    /*   Su uso no autorizado queda  expresamente  prohibido    */
    /*   asi como cualquier alteracion o agregado hecho  por    */
    /*   alguno de sus usuarios sin el debido consentimiento    */
    /*   por escrito de COBISCORP.                              */
    /*   Este programa esta protegido por la ley de derechos    */
    /*   de autor y por las y por las convenciones              */
    /*   internacionales de  propiedad intelectual. Su uso no   */
    /*   autorizado dara  derecho a  COBISCORP para obtener     */
    /*   ordenes de  secuestro o retencion y  para perseguir    */
    /*   penalmente a los autores de cualquier infraccion.      */
    /************************************************************/
    /*   This code was generated by CEN-SG.                     */
    /*   Changes to this file may cause incorrect behavior      */
    /*   and will be lost if the code is regenerated.           */
    /************************************************************/
    
    package  cobiscorp.ecobis.servicecontractoperations.service.rest;
    
    import com.cobiscorp.cobis.cts.rest.client.api.exception.CTSRestException;
    
    import cobiscorp.ecobis.servicecontractoperations.service.IServiceContractOperationsApiService;
    import cobiscorp.ecobis.datacontractoperations.dto.CreateCustomerRequest;
    import cobiscorp.ecobis.datacontractoperations.dto.CreateCustomerResponse;
    import cobiscorp.ecobis.datacontractoperations.dto.RequestEncriptData;
    import cobiscorp.ecobis.datacontractoperations.dto.ResponseEncriptData;
    import cobiscorp.ecobis.datacontractoperations.dto.RequestOtp;
    import cobiscorp.ecobis.datacontractoperations.dto.ResponseOtp;
    import cobiscorp.ecobis.datacontractoperations.dto.RequestCatalog;
    import cobiscorp.ecobis.datacontractoperations.dto.ResponseCatalog;
    import cobiscorp.ecobis.datacontractoperations.dto.RequestGetUserEntityInformation;
    import cobiscorp.ecobis.datacontractoperations.dto.ResponseGetUserEntityInformation;
    import cobiscorp.ecobis.datacontractoperations.dto.RequestValidateIdentity;
    import cobiscorp.ecobis.datacontractoperations.dto.ResponseValidateIdentity;
    
    import org.apache.felix.scr.annotations.*;
    import com.cobiscorp.cobis.commons.log.ILogger;
    import com.cobiscorp.cobis.commons.log.LogFactory;
    import javax.validation.constraints.NotNull;
    import javax.validation.constraints.Null;
    import javax.ws.rs.*;
    import javax.ws.rs.core.Response;
    import java.util.ArrayList;
    import java.util.List;
    import java.io.PrintWriter;
    import java.io.StringWriter;
    @Path("/cobis/api/Waltmart/ServiceContractOperations")
    @Component
    @Service({ServiceContractOperationsApiRest.class})
    public class ServiceContractOperationsApiRest {

    @Reference(name = "iServiceContractOperationsApiService", referenceInterface = IServiceContractOperationsApiService.class,
    bind = "setiServiceContractOperationsApiService", unbind = "unsetiServiceContractOperationsApiService", cardinality = ReferenceCardinality.MANDATORY_UNARY,
    policy = ReferencePolicy.DYNAMIC)
    IServiceContractOperationsApiService iServiceContractOperationsApiService;
    private static final ILogger LOGGER = LogFactory.getLogger(ServiceContractOperationsApiRest.class);
    protected void setiServiceContractOperationsApiService(IServiceContractOperationsApiService iServiceContractOperationsApiService){
    this.iServiceContractOperationsApiService = iServiceContractOperationsApiService;
    }

    protected void unsetiServiceContractOperationsApiService(IServiceContractOperationsApiService iServiceContractOperationsApiService){
    this.iServiceContractOperationsApiService = null;
    }
    
          /**
          * Create new customers
          */
        @POST
      @Path("/apiOperations/customer/createCustomer")
      @Consumes({"application/json"})
      @Produces({"application/json"})
       public Response  createCustomer(CreateCustomerRequest inCreateCustomerRequest ){
	  LOGGER.logDebug("Start service execution REST: createCustomer");
      CreateCustomerResponse outCreateCustomerResponse  = new CreateCustomerResponse();
          
      if(!validateMandatory()) {
        LOGGER.logDebug("400 is returned - Required fields are missing");
        return Response.status(400).entity("El mensaje de solicitud no se encuentra debidamente formateado").build();
      }
	    
      try {
      outCreateCustomerResponse=iServiceContractOperationsApiService.createCustomer( inCreateCustomerRequest );
      } catch (CTSRestException e) {
      LOGGER.logError("CTSRestException",e);
      if ("404".equals(e.getMessage())) {
      LOGGER.logDebug("404 is returned - No data found");
      return Response.status(404).entity("No data found").build();
      }

      LOGGER.logDebug("409 is returned - The stored procedure raise an error");
      return Response.status(409).entity(e.getMessageBlockList()).build();
      } catch (Exception e){
      LOGGER.logDebug("500 is returned - Code exception");
      LOGGER.logError("Exception",e);
      return Response.status(500).entity(e.getMessage()).build();
      }
      
          LOGGER.logDebug("Ends service execution REST: createCustomer");
          return Response.ok(outCreateCustomerResponse).build();
        
      }
    
          /**
          * Encrypt Data
          */
        @POST
      @Path("/apiOperations/security/encryptData")
      @Consumes({"application/json"})
      @Produces({"application/json"})
       public Response  encryptData(RequestEncriptData inRequestEncriptData ){
	  LOGGER.logDebug("Start service execution REST: encryptData");
      List<ResponseEncriptData> outSingleResponseEncriptData  = new ArrayList<>();
          
      if(!validateMandatory(new Data("externalCustomerId", inRequestEncriptData.getExternalCustomerId()), new Data("password", inRequestEncriptData.getPassword()))) {
        LOGGER.logDebug("400 is returned - Required fields are missing");
        return Response.status(400).entity("El mensaje de solicitud no se encuentra debidamente formateado").build();
      }
	    
      try {
      outSingleResponseEncriptData=iServiceContractOperationsApiService.encryptData( inRequestEncriptData );
      } catch (CTSRestException e) {
      LOGGER.logError("CTSRestException",e);
      if ("404".equals(e.getMessage())) {
      LOGGER.logDebug("404 is returned - No data found");
      return Response.status(404).entity("No data found").build();
      }

      LOGGER.logDebug("409 is returned - The stored procedure raise an error");
      return Response.status(409).entity(e.getMessageBlockList()).build();
      } catch (Exception e){
      LOGGER.logDebug("500 is returned - Code exception");
      LOGGER.logError("Exception",e);
      return Response.status(500).entity(e.getMessage()).build();
      }
      
          LOGGER.logDebug("Ends service execution REST: encryptData");
          return Response.ok(outSingleResponseEncriptData).build();
        
      }
    
          /**
          * Service to generate and send an OTP to the client
          */
        @POST
      @Path("/apiOperations/password/generateTransactionFactor")
      @Consumes({"application/json"})
      @Produces({"application/json"})
       public Response  generateTransactionFactor(RequestOtp inRequestOtp ){
	  LOGGER.logDebug("Start service execution REST: generateTransactionFactor");
      List<ResponseOtp> outSingleResponseOtp  = new ArrayList<>();
          
      if(!validateMandatory(new Data("externalCustomerId", inRequestOtp.getExternalCustomerId()))) {
        LOGGER.logDebug("400 is returned - Required fields are missing");
        return Response.status(400).entity("El mensaje de solicitud no se encuentra debidamente formateado").build();
      }
	    
      try {
      outSingleResponseOtp=iServiceContractOperationsApiService.generateTransactionFactor( inRequestOtp );
      } catch (CTSRestException e) {
      LOGGER.logError("CTSRestException",e);
      if ("404".equals(e.getMessage())) {
      LOGGER.logDebug("404 is returned - No data found");
      return Response.status(404).entity("No data found").build();
      }

      LOGGER.logDebug("409 is returned - The stored procedure raise an error");
      return Response.status(409).entity(e.getMessageBlockList()).build();
      } catch (Exception e){
      LOGGER.logDebug("500 is returned - Code exception");
      LOGGER.logError("Exception",e);
      return Response.status(500).entity(e.getMessage()).build();
      }
      
          LOGGER.logDebug("Ends service execution REST: generateTransactionFactor");
          return Response.ok(outSingleResponseOtp).build();
        
      }
    
          /**
          * Get catalog
          */
        @POST
      @Path("/apiOperations/common/getCatalog")
      @Consumes({"application/json"})
      @Produces({"application/json"})
        public Response  getCatalog(RequestCatalog inRequestCatalog ){
      	  LOGGER.logDebug("Start service execution REST: getCatalog");
            ResponseCatalog outResponseCatalog  = new ResponseCatalog();
                
        /*    if(!validateMandatory()) {
              LOGGER.logDebug("400 is returned - Required fields are missing");
              return Response.status(400).entity("El mensaje de solicitud no se encuentra debidamente formateado").build();
            }*/
      	    
            try {
            outResponseCatalog=iGetCatalogServiceApiService.getCatalog( inRequestCatalog );
            } catch (CTSRestException e) {
            LOGGER.logError("CTSRestException",e);
            if ("404".equals(e.getMessage())) {
            LOGGER.logDebug("404 is returned - No data found");
            return Response.status(404).entity("No data found").build();
            }

          /*  LOGGER.logDebug("409 is returned - The stored procedure raise an error");
            return Response.status(409).entity(e.getMessageBlockList()).build();*/
            } catch (Exception e){
            LOGGER.logDebug("500 is returned - Code exception");
            LOGGER.logError("Exception",e);
            return Response.status(500).entity(e.getMessage()).build();
            }
            
                LOGGER.logDebug("Ends service execution REST: getCatalog");
                return Response.ok(outResponseCatalog).build();
              
            }
    
          /**
          * View Customer Information
          */
        @POST
      @Path("/apiOperations/enrollment/getUserEntityInformation")
      @Consumes({"application/json"})
      @Produces({"application/json"})
       public Response  getUserEntityInformation(RequestGetUserEntityInformation inRequestGetUserEntityInformation ){
	  LOGGER.logDebug("Start service execution REST: getUserEntityInformation");
      ResponseGetUserEntityInformation outResponseGetUserEntityInformation  = new ResponseGetUserEntityInformation();
          
      if(!validateMandatory()) {
        LOGGER.logDebug("400 is returned - Required fields are missing");
        return Response.status(400).entity("El mensaje de solicitud no se encuentra debidamente formateado").build();
      }
	    
      try {
      outResponseGetUserEntityInformation=iServiceContractOperationsApiService.getUserEntityInformation( inRequestGetUserEntityInformation );
      } catch (CTSRestException e) {
      LOGGER.logError("CTSRestException",e);
      if ("404".equals(e.getMessage())) {
      LOGGER.logDebug("404 is returned - No data found");
      return Response.status(404).entity("No data found").build();
      }

      LOGGER.logDebug("409 is returned - The stored procedure raise an error");
      return Response.status(409).entity(e.getMessageBlockList()).build();
      } catch (Exception e){
      LOGGER.logDebug("500 is returned - Code exception");
      LOGGER.logError("Exception",e);
      return Response.status(500).entity(e.getMessage()).build();
      }
      
          LOGGER.logDebug("Ends service execution REST: getUserEntityInformation");
          return Response.ok(outResponseGetUserEntityInformation).build();
        
      }
    
          /**
          * Validate Identity
          */
        @POST
      @Path("/apiOperations/onbording/sendImagesToMati")
      @Consumes({"application/json"})
      @Produces({"application/json"})
       public Response  validateIdentity(RequestValidateIdentity inRequestValidateIdentity ){
	  LOGGER.logDebug("Start service execution REST: validateIdentity");
      ResponseValidateIdentity outResponseValidateIdentity  = new ResponseValidateIdentity();
          
      if(!validateMandatory()) {
        LOGGER.logDebug("400 is returned - Required fields are missing");
        return Response.status(400).entity("El mensaje de solicitud no se encuentra debidamente formateado").build();
      }
	    
      try {
      outResponseValidateIdentity=iServiceContractOperationsApiService.validateIdentity( inRequestValidateIdentity );
      } catch (CTSRestException e) {
      LOGGER.logError("CTSRestException",e);
      if ("404".equals(e.getMessage())) {
      LOGGER.logDebug("404 is returned - No data found");
      return Response.status(404).entity("No data found").build();
      }

      LOGGER.logDebug("409 is returned - The stored procedure raise an error");
      return Response.status(409).entity(e.getMessageBlockList()).build();
      } catch (Exception e){
      LOGGER.logDebug("500 is returned - Code exception");
      LOGGER.logError("Exception",e);
      return Response.status(500).entity(e.getMessage()).build();
      }
      
          LOGGER.logDebug("Ends service execution REST: validateIdentity");
          return Response.ok(outResponseValidateIdentity).build();
        
      }
    
    private class Data {
      private String name;
      private Object value;
      public Data(String name, Object value) {
        super();
        this.name = name;
        this.value = value;
      }
      public String getName() {
        return name;
      }
      public Object getValue() {
        return value;
      }
    }

    private boolean validateMandatory(Data... args) {
      boolean res = true;
      for (Data arg : args) {
        if ( arg.getValue() == null ) {
          LOGGER.logError("Attribute " + arg.getName() + " is null");
          res = false;
        }
      }
      return res;
    }
    
    }
  