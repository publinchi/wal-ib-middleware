
    /************************************************************/
    /*                     IMPORTANTE                           */
    /*   Esta aplicacion es parte de los  paquetes bancarios    */
    /*   propiedad de COBISCORP.                                */
    /*   Su uso no autorizado queda  expresamente  prohibido    */
    /*   asi como cualquier alteracion o agregado hecho  por    */
    /*   alguno de sus usuarios sin el debido consentimiento    */
    /*   por escrito de COBISCORP.                              */
    /*   Este programa esta protegido por la ley de derechos    */
    /*   de autor y por las y por las convenciones              */
    /*   internacionales de  propiedad intelectual. Su uso no   */
    /*   autorizado dara  derecho a  COBISCORP para obtener     */
    /*   ordenes de  secuestro o retencion y  para perseguir    */
    /*   penalmente a los autores de cualquier infraccion.      */
    /************************************************************/
    /*   This code was generated by CEN-SG.                     */
    /*   Changes to this file may cause incorrect behavior      */
    /*   and will be lost if the code is regenerated.           */
    /************************************************************/
    
    package  cobiscorp.ecobis.servicecontractoperations.service;
    
    import com.cobiscorp.cobis.cts.rest.client.api.exception.CTSRestException;
    import com.cobiscorp.cobis.commons.log.ILogger;
    import com.cobiscorp.cobis.commons.log.LogFactory;
    import com.cobiscorp.cobis.cts.rest.client.api.RowMapper;
    import com.cobiscorp.cobis.cts.rest.client.dto.MessageBlock;
    import com.cobiscorp.cobis.cts.rest.client.dto.ProcedureRequestAS;
    import com.cobiscorp.cobis.cts.rest.client.dto.ProcedureResponseAS;
    import com.cobiscorp.cobis.cts.rest.client.dto.ProcedureResponseParam;
    import com.cobiscorp.cobis.cts.rest.client.mapper.MapperResultUtil;
    import com.cobiscorp.cobis.cts.rest.client.mapper.ResultSetMapper;
    import com.cobiscorp.cobis.cts.rest.client.util.ErrorUtil;
    import com.cobiscorp.cobis.cwc.cts.rest.ICTSRestIntegrationService;
    import com.cobiscorp.cobis.jaxrs.publisher.SessionManager;
    import org.apache.felix.scr.annotations.*;
    import java.math.BigDecimal;
    import java.util.ArrayList;
    import java.util.List;
    import java.util.Arrays;
    
    import com.cobiscorp.cobis.cts.rest.client.util.ConverterUtil;
    import com.cobiscorp.cobis.cts.rest.client.util.ICTSTypes;
    
    import cobiscorp.ecobis.servicecontractoperations.service.IServiceContractOperationsApiService;
    import cobiscorp.ecobis.datacontractoperations.dto.*;
   
    @Component
    @Service({IServiceContractOperationsApiService.class})
    public class ServiceContractOperationsApiService implements IServiceContractOperationsApiService{

    @Reference(name = "ctsRestIntegrationService", referenceInterface = ICTSRestIntegrationService.class,
    bind = "setctsRestIntegrationService", unbind = "unsetctsRestIntegrationService", cardinality = ReferenceCardinality.MANDATORY_UNARY,
    policy = ReferencePolicy.DYNAMIC)
    private ICTSRestIntegrationService ctsRestIntegrationService;
    private static final ILogger LOGGER = LogFactory.getLogger(ServiceContractOperationsApiService.class);

    
          /**
          * Encrypt Data
          */
         @Override
			// Return List
			public  List<ResponseEncriptData>  encryptData(RequestEncriptData inRequestEncriptData  )throws CTSRestException{
	  LOGGER.logDebug("Start service execution: encryptData");
      List<ResponseEncriptData> outSingleResponseEncriptData  = new ArrayList<>();
          
      //create procedure
      ProcedureRequestAS procedureRequestAS = new ProcedureRequestAS("cob_procesador..sp_encryptData");
      
        procedureRequestAS.addInputParam("@t_trn",ICTSTypes.SQLINT4,"18500088");
      procedureRequestAS.addInputParam("@i_external_customer_id",ICTSTypes.SQLINT4,String.valueOf(inRequestEncriptData.getExternalCustomerId()));
      procedureRequestAS.addInputParam("@i_password",ICTSTypes.SQLVARCHAR,inRequestEncriptData.getDecriptedData());
      
      //execute procedure
      ProcedureResponseAS response = ctsRestIntegrationService.execute(SessionManager.getSessionId(), null,procedureRequestAS);

      List<MessageBlock> errors = ErrorUtil.getErrors(response);
      //throw error
      if(errors!= null && errors.size()> 0){
      LOGGER.logDebug("Procedure execution returns error");
      if ( LOGGER.isDebugEnabled() ) {
      for (int i = 0; i < errors.size(); i++) {
      LOGGER.logDebug("CTSErrorMessage: " + errors.get(i));
      }
      }
      throw new CTSRestException("Procedure Response has errors", null, errors);
      }
      LOGGER.logDebug("Procedure ok");
      //Init map returns
      int mapTotal=0;
      int mapBlank=0;
      
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(0).getData().getRows().size()>0) {
                    //----------------Assume Array return
                    List<ResponseEncriptData> returnResponseEncriptData = MapperResultUtil.mapToList(response.getResultSets().get(0), new RowMapper<ResponseEncriptData>() { 
                    @Override
                    public ResponseEncriptData mapRow(ResultSetMapper resultSetMapper, int index) {
                    ResponseEncriptData dto = new ResponseEncriptData();
                    
                          dto.setSuccess(resultSetMapper.getBooleanWrapper(1));
                          dto.setEncryptedData(resultSetMapper.getString(2));
							dto.messageInstance().setMessage(resultSetMapper.getString(3));
							dto.messageInstance().setCode(resultSetMapper.getInteger(4));
                    return dto;
                    }
                    },false);
                    outSingleResponseEncriptData=returnResponseEncriptData ;
                    
            }else {
            mapBlank++;

            }
          
      //End map returns
      if(mapBlank!=0&&mapBlank==mapTotal){
      LOGGER.logDebug("No data found");
      throw new CTSRestException("404",null);
      }
      
        LOGGER.logDebug("Ends service execution: encryptData");
        //returns data
        return outSingleResponseEncriptData;
      }
    
          /**
          * Service to generate and send an OTP to the client
          */
         @Override
			// Return List
			public  List<ResponseOtp>  generateTransactionFactor(RequestOtp inRequestOtp  )throws CTSRestException{
	  LOGGER.logDebug("Start service execution: generateTransactionFactor");
      List<ResponseOtp> outSingleResponseOtp  = new ArrayList<>();
          
      //create procedure
      ProcedureRequestAS procedureRequestAS = new ProcedureRequestAS("cob_procesador..administra_token");
      
        procedureRequestAS.addInputParam("@t_trn",ICTSTypes.SQLINT4,"18500090");
      procedureRequestAS.addInputParam("@i_external_customer_id",ICTSTypes.SQLINT4,String.valueOf(inRequestOtp.getExternalCustomerId()));
      
      //execute procedure
      ProcedureResponseAS response = ctsRestIntegrationService.execute(SessionManager.getSessionId(), null,procedureRequestAS);

      List<MessageBlock> errors = ErrorUtil.getErrors(response);
      //throw error
      if(errors!= null && errors.size()> 0){
      LOGGER.logDebug("Procedure execution returns error");
      if ( LOGGER.isDebugEnabled() ) {
      for (int i = 0; i < errors.size(); i++) {
      LOGGER.logDebug("CTSErrorMessage: " + errors.get(i));
      }
      }
      throw new CTSRestException("Procedure Response has errors", null, errors);
      }
      LOGGER.logDebug("Procedure ok");
      //Init map returns
      int mapTotal=0;
      int mapBlank=0;
      
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(0).getData().getRows().size()>0) {
                    //----------------Assume Array return
                    List<ResponseOtp> returnResponseOtp = MapperResultUtil.mapToList(response.getResultSets().get(0), new RowMapper<ResponseOtp>() { 
                    @Override
                    public ResponseOtp mapRow(ResultSetMapper resultSetMapper, int index) {
                    ResponseOtp dto = new ResponseOtp();
                    
                          dto.setSuccess(resultSetMapper.getBooleanWrapper(1));
							dto.messageInstance().setCode(resultSetMapper.getInteger(2));
							dto.messageInstance().setMessage(resultSetMapper.getString(3));
                    return dto;
                    }
                    },false);
                    outSingleResponseOtp=returnResponseOtp ;
                    
            }else {
            mapBlank++;

            }
          
      //End map returns
      if(mapBlank!=0&&mapBlank==mapTotal){
      LOGGER.logDebug("No data found");
      throw new CTSRestException("404",null);
      }
      
        LOGGER.logDebug("Ends service execution: generateTransactionFactor");
        //returns data
        return outSingleResponseOtp;
      }
    
          /**
          * Get catalog
          */
         @Override
			// Return List
			public  List<ResponseCatalog>  getCatalog(RequestCatalog inRequestCatalog  )throws CTSRestException{
	  LOGGER.logDebug("Start service execution: getCatalog");
      List<ResponseCatalog> outSingleResponseCatalog  = new ArrayList<>();
          
      //create procedure
      ProcedureRequestAS procedureRequestAS = new ProcedureRequestAS("cob_procesador..sp_get_catalog_data");
      
        procedureRequestAS.addInputParam("@t_trn",ICTSTypes.SQLINT4,"18500087");
      procedureRequestAS.addInputParam("@i_catalog",ICTSTypes.SQLVARCHAR,inRequestCatalog.getCatalogueTable());
      
      //execute procedure
      ProcedureResponseAS response = ctsRestIntegrationService.execute(SessionManager.getSessionId(), null,procedureRequestAS);

      List<MessageBlock> errors = ErrorUtil.getErrors(response);
      //throw error
      if(errors!= null && errors.size()> 0){
      LOGGER.logDebug("Procedure execution returns error");
      if ( LOGGER.isDebugEnabled() ) {
      for (int i = 0; i < errors.size(); i++) {
      LOGGER.logDebug("CTSErrorMessage: " + errors.get(i));
      }
      }
      throw new CTSRestException("Procedure Response has errors", null, errors);
      }
      LOGGER.logDebug("Procedure ok");
      //Init map returns
      int mapTotal=0;
      int mapBlank=0;
      
            mapTotal++;
            if (response.getResultSets()!=null&&response.getResultSets().get(0).getData().getRows().size()>0) {
                    //----------------Assume Array return
                    List<ResponseCatalog> returnResponseCatalog = MapperResultUtil.mapToList(response.getResultSets().get(0), new RowMapper<ResponseCatalog>() { 
                    @Override
                    public ResponseCatalog mapRow(ResultSetMapper resultSetMapper, int index) {
                    ResponseCatalog dto = new ResponseCatalog();
                    
                              dto.setCatalogueItems(new CatalogueItems[] {new CatalogueItems()});
							dto.getCatalogueItems()[0].setCode(resultSetMapper.getString(1));
							dto.getCatalogueItems()[0].setName(resultSetMapper.getString(2));
                          dto.setSuccess(resultSetMapper.getBooleanWrapper(3));
							dto.messageInstance().setCode(resultSetMapper.getInteger(4));
							dto.messageInstance().setMessage(resultSetMapper.getString(5));
                    return dto;
                    }
                    },false);
                    outSingleResponseCatalog=returnResponseCatalog ;
                    
            }else {
            mapBlank++;

            }
          
      //End map returns
      if(mapBlank!=0&&mapBlank==mapTotal){
      LOGGER.logDebug("No data found");
      throw new CTSRestException("404",null);
      }
      
        LOGGER.logDebug("Ends service execution: getCatalog");
        //returns data
        return outSingleResponseCatalog;
      }
    

    protected void setctsRestIntegrationService(ICTSRestIntegrationService ctsRestIntegrationService){
      this.ctsRestIntegrationService = ctsRestIntegrationService;
    }

    protected void unsetctsRestIntegrationService(ICTSRestIntegrationService ctsRestIntegrationService){
      this.ctsRestIntegrationService = null;
    }

    @SuppressWarnings("unchecked")
    private <T extends Object> T getOutValue(Class<T> type, String name, List<ProcedureResponseParam> params) throws CTSRestException {
      for (ProcedureResponseParam param : params) {
        if(param.getName().equals(name)) {
          if(type.getCanonicalName() == "java.lang.String") {
            return (T) param.getValue();
          }
          return parse(type, param.getValue());
        }
      }
      LOGGER.logError("Output param " + name + " not found");
      throw new CTSRestException("404",null);
    }
    
    @SuppressWarnings("unchecked")
    private <T extends Object> T parse(Class<T> type, String value) {
      if (value != null && !"null".equals(value)) {
        if (value.trim().length() == 0) {
          if (type.getCanonicalName().equals("java.lang.Character")) {
            Character ch = ' ';
            return (T) ch;
          } else {
            return null;
          }
        } else {
          switch (type.getCanonicalName()) {
            case "java.lang.Byte":
              return (T) new Byte(value);
            case "java.lang.Long":
              return (T) new Long(value);
            case "java.lang.Double":
              return (T) new Double(value);
            case "java.lang.Integer":
              return (T) new Integer(value);
            case "java.util.Calendar":
              return (T) ConverterUtil.stringToCalendar(value);
            case "java.lang.Boolean":
              return (T) new Boolean(value);
            case "java.math.BigDecimal":
              return (T) new BigDecimal(value);
            case "java.lang.Character":
              Character ch = value.substring(0, value.length() - 1).charAt(0);
              return (T) ch;
            default:
              break;
          }
        }
      }
      return null;
    }
    
    }

  